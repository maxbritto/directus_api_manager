import 'package:directus_api_manager/directus_api_manager.dart';

abstract class DirectusData {
  static const String idKey = "id";
  static const String userCreatedKey = "user_created";

  final Map<String, dynamic> _rawReceivedData;
  final Map<String, dynamic> updatedProperties = {};

  DirectusData(this._rawReceivedData) {
    if (!_rawReceivedData.containsKey("id")) {
      throw Exception("id is required");
    }
  }

  DirectusData.newDirectusData([this._rawReceivedData = const {}]);
  DirectusData.withId(dynamic id) : this({"id": id});

  /// This field is used to store the id of the user that created the item.
  String? get userCreated => getValue(forKey: userCreatedKey);
  set userCreated(String? value) => setValue(value, forKey: userCreatedKey);

  /// Returns the id of the item
  /// We respect directus recommandations of having an [id] field for each collection.
  /// It can be null because a new item can be created without an id and will get its id generated by the server
  /// If you fetched the item from the server, it will have an id and it will certainly never be null
  String? get id {
    dynamic idData = getValue(forKey: idKey);
    if (idData is int) {
      return idData.toString();
    }

    return idData;
  }

  /// Returns the id of the item if you used `Integer` as the [id] type in Directus
  int? get intId {
    dynamic idData = getValue(forKey: idKey);
    if (idData is int) {
      return idData;
    }

    return null;
  }

  Map<String, dynamic> getRawData() => _rawReceivedData;
  bool get needsSaving => updatedProperties.isNotEmpty;

  bool hasChangedIn({required String forKey}) =>
      updatedProperties.containsKey(forKey);

  void setValue(dynamic value, {required String forKey}) {
    if (value != getValue(forKey: forKey) ||
        _rawReceivedData.containsKey(forKey) == false) {
      updatedProperties[forKey] = value;
    }
  }

  dynamic getValue({required String forKey}) {
    return updatedProperties.containsKey(forKey)
        ? updatedProperties[forKey]
        : _rawReceivedData[forKey];
  }

  DirectusFile getDirectusFile({required String forKey}) {
    final dynamic value = getOptionalDirectusFile(forKey: forKey);
    assert(value != null);
    return value;
  }

  DirectusFile? getOptionalDirectusFile({required String forKey}) {
    final dynamic value = getValue(forKey: forKey);
    if (value is Map<String, dynamic>) {
      return DirectusFile(value);
    } else if (value is String) {
      return DirectusFile.fromId(value);
    }
    return null;
  }

  /// Set a DirectusFile to the value of the given key
  /// If the file is null, the value will be set to null
  void setOptionalDirectusFile(DirectusFile? file, {required String forKey}) {
    if (file != null) {
      setValue(file.id, forKey: forKey);
    } else {
      setValue(null, forKey: forKey);
    }
  }

  List<T> getObjectList<T>(
      {required String forKey,
      required T Function(Map<String, dynamic>) fromMap}) {
    final dynamic value = getValue(forKey: forKey);
    if (value is List<dynamic>) {
      return value.map((e) => fromMap(e)).toList();
    }
    return [];
  }

  /// Returns a list of String for a given property.
  /// Only use this property if you are certain your property will be a list whose members can be converted to String using [toString]
  /// If the property is not a list, an empty list will be returned
  @Deprecated(
    "Use `getList<String>` instead",
  )
  List<String> getStringList({required String forKey}) {
    final dynamic value = getValue(forKey: forKey);
    if (value is List<dynamic>) {
      return value.map((e) => e.toString()).toList();
    }
    return [];
  }

  /// Returns a list of the given type for a given property.
  /// Only use this property if you are certain your property will be of this type for every object in the collection
  /// If the property is not a list, an empty list will be returned
  List<T> getList<T>({required String forKey}) {
    final dynamic value = getValue(forKey: forKey);
    if (value is List<dynamic>) {
      return value.map((e) => e as T).toList();
    }
    return [];
  }

  /// Returns a DateTime if the value is a DateTime or a String that can be parsed as a DateTime
  /// This property can be used if you are not certain your property will be filled for every object in the collection
  DateTime? getOptionalDateTime({required String forKey}) {
    final dynamic value = getValue(forKey: forKey);
    DateTime? date;
    if (value is DateTime) {
      date = value;
    } else if (value is String) {
      date = DateTime.tryParse(value);
    }
    return date;
  }

  /// Returns a DateTime for a given property.
  /// Only use this property if you are certain your property will be filled for every object in the collection
  /// If you are not certain, use [getOptionalDateTime] instead
  DateTime getDateTime({required String forKey}) {
    final dynamic value = getOptionalDateTime(forKey: forKey);
    assert(value != null);
    return value!;
  }

  /// Sets a DateTime for a given property.
  /// if the value is null, the property will be removed from the updated properties
  void setOptionalDateTime(DateTime? value, {required String forKey}) {
    if (value != null) {
      setValue(value.toIso8601String(), forKey: forKey);
    } else {
      setValue(null, forKey: forKey);
    }
  }

  /// Returns a DirectusGeometryType for a given property.
  /// Only use this property if you are certain your property will be filled for every object in the collection
  /// If you are not certain, use [getOptionalDirectusGeometryType] instead
  DirectusGeometryType getDirectusGeometryType({required String forKey}) {
    final dynamic value = getOptionalDirectusGeometryType(forKey: forKey);
    assert(value != null);
    return value;
  }

  /// Returns a DirectusGeometryType if the value is a Map that can be converted to a DirectusGeometryType
  /// This property can be used if you are not certain your property will be filled for every object in the collection
  /// If the property is not a Map, null will be returned
  DirectusGeometryType? getOptionalDirectusGeometryType(
      {required String forKey}) {
    final dynamic value = getValue(forKey: forKey);
    if (value is Map<String, dynamic>) {
      return DirectusGeometryType.fromJSON(value);
    }
    return null;
  }

  /// returns a map of all the properties of the item merged with the ones that have been updated
  Map<String, dynamic> toMap() {
    return Map<String, dynamic>.of(_rawReceivedData)..addAll(updatedProperties);
  }

  /// Returns a map of all the properties of the item without the id that must not be sent to the server when creating a new item
  Map<String, dynamic> mapForObjectCreation() {
    return toMap()..remove("id");
  }
}
